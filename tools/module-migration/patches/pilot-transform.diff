diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3923036..d37c1ae 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -46,7 +46,10 @@ set(CMAKE_CXX_STANDARD 23)
 if (MSVC)
   add_compile_options(/bigobj)
 else ()
-  add_compile_options(-Wa,-mbig-obj)
+  # -Wa,-mbig-obj is MinGW-specific, skip for other compilers
+  if (MINGW)
+    add_compile_options(-Wa,-mbig-obj)
+  endif()
   add_compile_options(-Wpointer-arith)
   add_compile_options(-fpch-preprocess)
 endif ()
diff --git a/epix_engine/CMakeLists.txt b/epix_engine/CMakeLists.txt
index b74437d..0237548 100644
--- a/epix_engine/CMakeLists.txt
+++ b/epix_engine/CMakeLists.txt
@@ -12,6 +12,16 @@ set(EPIX_USE_VOLK ON)
 # BUILD STATIC
 add_library(epix_engine STATIC ${MODULE_SOURCES})
 
+# Enable C++20 for module support
+target_compile_features(epix_engine PUBLIC cxx_std_20)
+
+# Add module interface files
+target_sources(epix_engine
+  PUBLIC
+    FILE_SET CXX_MODULES FILES
+      ${CMAKE_CURRENT_SOURCE_DIR}/src/modules/epix.transform.cppm
+)
+
 if(EPIX_ENABLE_TRACY)
   target_compile_definitions(epix_engine PRIVATE EPIX_ENABLE_TRACY)
 endif()
diff --git a/epix_engine/archived_headers/transform/transform.hpp.20251212-001402 b/epix_engine/archived_headers/transform/transform.hpp.20251212-001402
new file mode 100644
index 0000000..331bdbf
--- /dev/null
+++ b/epix_engine/archived_headers/transform/transform.hpp.20251212-001402
@@ -0,0 +1,138 @@
+#pragma once
+
+#include <epix/core.hpp>
+#include <glm/glm.hpp>
+#include <glm/gtc/matrix_transform.hpp>
+#include <glm/gtc/quaternion.hpp>
+#include <glm/gtc/type_ptr.hpp>
+
+namespace epix::transform {
+template <typename T = float>
+struct TransformT {
+    glm::vec<3, T> translation{0.0f, 0.0f, 0.0f};
+    glm::qua<T> rotation{1.0f, 0.0f, 0.0f, 0.0f};
+    glm::vec<3, T> scaler{1.0f, 1.0f, 1.0f};
+
+    static TransformT identity() { return TransformT(); }
+    static TransformT from_matrix(const glm::mat4& matrix) {
+        TransformT t;
+        t.translation = glm::vec3(matrix[3]);
+        t.scaler      = glm::vec3(glm::length(matrix[0]), glm::length(matrix[1]), glm::length(matrix[2]));
+        // get the pure rotation matrix
+        glm::mat3 rotationMatrix = glm::mat3(matrix);
+        // normalize the rotation matrix
+        rotationMatrix[0] /= t.scaler.x;
+        rotationMatrix[1] /= t.scaler.y;
+        rotationMatrix[2] /= t.scaler.z;
+        t.rotation = glm::quat_cast(rotationMatrix);
+        return t;
+    }
+    static TransformT from_translation(const glm::vec3& translation) {
+        TransformT t;
+        t.translation = translation;
+        return t;
+    }
+    static TransformT from_xyz(float x, float y, float z) { return from_translation(glm::vec3(x, y, z)); }
+    static TransformT from_rotation(const glm::quat& rotation) {
+        TransformT t;
+        t.rotation = rotation;
+        return t;
+    }
+    static TransformT from_scale(const glm::vec3& scale) {
+        TransformT t;
+        t.scaler = scale;
+        return t;
+    }
+
+    auto&& look_at(this auto&& t, const glm::vec3& target, const glm::vec3& up) {
+        glm::vec3 direction = glm::normalize(target - t.translation);
+        t.rotation          = glm::quatLookAt(direction, up);
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& look_to(this auto&& t, const glm::vec3& direction, const glm::vec3& up) {
+        t.rotation = glm::quatLookAt(direction, up);
+        return std::forward<decltype(t)>(t);
+    }
+
+    glm::mat4 to_matrix(this const TransformT& t) {
+        glm::mat3 rotate = glm::mat3_cast(t.rotation);
+        glm::mat4 matrix(glm::vec4(rotate[0] * t.scaler.x, 0.0f), glm::vec4(rotate[1] * t.scaler.y, 0.0f),
+                         glm::vec4(rotate[2] * t.scaler.z, 0.0f), glm::vec4(t.translation, 1.0f));
+        return matrix;
+    }
+
+    glm::vec3 local_x(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(1.0f, 0.0f, 0.0f)); }
+    glm::vec3 local_y(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(0.0f, 1.0f, 0.0f)); }
+    glm::vec3 local_z(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(0.0f, 0.0f, 1.0f)); }
+
+    // Adding rotation in the parent space
+    auto&& rotate(this auto&& t, const glm::quat& rotation) {
+        t.rotation = rotation * t.rotation;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& rotate(this auto&& t, const glm::vec3& axis, float angle) { return t.rotate(glm::angleAxis(angle, axis)); }
+    auto&& rotate_x(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(1.0f, 0.0f, 0.0f))); }
+    auto&& rotate_y(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f))); }
+    auto&& rotate_z(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f))); }
+    // Adding rotation in the local space
+    auto&& rotate_local(this auto&& t, const glm::quat& rotation) {
+        t.rotation = t.rotation * rotation;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& rotate_local(this auto&& t, const glm::vec3& axis, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, axis));
+    }
+    auto&& rotate_local_x(this auto&& t, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, glm::vec3(1.0f, 0.0f, 0.0f)));
+    }
+    auto&& rotate_local_y(this auto&& t, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f)));
+    }
+    auto&& rotate_local_z(this auto&& t, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f)));
+    }
+    auto&& translate(this auto&& t, const glm::vec3& translation) {
+        t.translation += translation;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& translate(this auto&& t, float x, float y, float z) { return t.translate(glm::vec3(x, y, z)); }
+    auto&& scale(this auto&& t, const glm::vec3& scale) {
+        t.scaler *= scale;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& scale(this auto&& t, float x, float y, float z) { return t.scale(glm::vec3(x, y, z)); }
+
+    auto&& translate_around(this auto&& t, const glm::vec3& point, const glm::quat& rotation) {
+        t.translation = point + rotation * (t.translation - point);
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& rotate_around(this auto&& t, const glm::vec3& point, const glm::quat& rotation) {
+        return t.translate_around(point, rotation).rotate(rotation);
+    }
+
+    TransformT operator*(this TransformT t, const TransformT& other) {
+        t.translation = other * t.translation;
+        t.rotation    = other.rotation * t.rotation;
+        t.scaler *= other.scaler;
+        return t;
+    }
+    glm::vec3 operator*(this const TransformT& t, const glm::vec3& v) {
+        return t.translation + t.rotation * (v * t.scaler);
+    }
+
+    TransformT mul_transform(this const TransformT& t, const TransformT& other) { return t * other; }
+    glm::vec3 mul_vec3(this const TransformT& t, const glm::vec3& v) { return t * v; }
+};
+using Transform  = TransformT<float>;
+using DTransform = TransformT<double>;
+struct GlobalTransform {
+    glm::mat4 matrix{1.0f};
+};
+
+enum class TransformSets {
+    CalculateGlobalTransform = 0,
+};
+struct TransformPlugin {
+    void build(App& app);
+};
+}  // namespace epix::transform
\ No newline at end of file
diff --git a/epix_engine/src/modules/epix.transform.cppm b/epix_engine/src/modules/epix.transform.cppm
new file mode 100644
index 0000000..d23f3fe
--- /dev/null
+++ b/epix_engine/src/modules/epix.transform.cppm
@@ -0,0 +1,154 @@
+// Module interface for epix.transform
+// Converted from epix_engine/transform/include/epix/transform.hpp
+export module epix.transform;
+
+// Import necessary standard library modules
+// Note: C++20 modules for std library may not be fully available yet,
+// so we'll use traditional includes within the global module fragment
+module;
+
+// Global module fragment - traditional includes go here
+#include <epix/core.hpp>
+#include <glm/glm.hpp>
+#include <glm/gtc/matrix_transform.hpp>
+#include <glm/gtc/quaternion.hpp>
+#include <glm/gtc/type_ptr.hpp>
+
+export module epix.transform;
+
+// Export the transform namespace and its contents
+export namespace epix::transform {
+
+template <typename T = float>
+struct TransformT {
+    glm::vec<3, T> translation{0.0f, 0.0f, 0.0f};
+    glm::qua<T> rotation{1.0f, 0.0f, 0.0f, 0.0f};
+    glm::vec<3, T> scaler{1.0f, 1.0f, 1.0f};
+
+    static TransformT identity() { return TransformT(); }
+    static TransformT from_matrix(const glm::mat4& matrix) {
+        TransformT t;
+        t.translation = glm::vec3(matrix[3]);
+        t.scaler      = glm::vec3(glm::length(matrix[0]), glm::length(matrix[1]), glm::length(matrix[2]));
+        // get the pure rotation matrix
+        glm::mat3 rotationMatrix = glm::mat3(matrix);
+        // normalize the rotation matrix
+        rotationMatrix[0] /= t.scaler.x;
+        rotationMatrix[1] /= t.scaler.y;
+        rotationMatrix[2] /= t.scaler.z;
+        t.rotation = glm::quat_cast(rotationMatrix);
+        return t;
+    }
+    static TransformT from_translation(const glm::vec3& translation) {
+        TransformT t;
+        t.translation = translation;
+        return t;
+    }
+    static TransformT from_xyz(float x, float y, float z) { return from_translation(glm::vec3(x, y, z)); }
+    static TransformT from_rotation(const glm::quat& rotation) {
+        TransformT t;
+        t.rotation = rotation;
+        return t;
+    }
+    static TransformT from_scale(const glm::vec3& scale) {
+        TransformT t;
+        t.scaler = scale;
+        return t;
+    }
+
+    auto&& look_at(this auto&& t, const glm::vec3& target, const glm::vec3& up) {
+        glm::vec3 direction = glm::normalize(target - t.translation);
+        t.rotation          = glm::quatLookAt(direction, up);
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& look_to(this auto&& t, const glm::vec3& direction, const glm::vec3& up) {
+        t.rotation = glm::quatLookAt(direction, up);
+        return std::forward<decltype(t)>(t);
+    }
+
+    glm::mat4 to_matrix(this const TransformT& t) {
+        glm::mat3 rotate = glm::mat3_cast(t.rotation);
+        glm::mat4 matrix(glm::vec4(rotate[0] * t.scaler.x, 0.0f), glm::vec4(rotate[1] * t.scaler.y, 0.0f),
+                         glm::vec4(rotate[2] * t.scaler.z, 0.0f), glm::vec4(t.translation, 1.0f));
+        return matrix;
+    }
+
+    glm::vec3 local_x(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(1.0f, 0.0f, 0.0f)); }
+    glm::vec3 local_y(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(0.0f, 1.0f, 0.0f)); }
+    glm::vec3 local_z(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(0.0f, 0.0f, 1.0f)); }
+
+    // Adding rotation in the parent space
+    auto&& rotate(this auto&& t, const glm::quat& rotation) {
+        t.rotation = rotation * t.rotation;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& rotate(this auto&& t, const glm::vec3& axis, float angle) { return t.rotate(glm::angleAxis(angle, axis)); }
+    auto&& rotate_x(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(1.0f, 0.0f, 0.0f))); }
+    auto&& rotate_y(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f))); }
+    auto&& rotate_z(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f))); }
+    // Adding rotation in the local space
+    auto&& rotate_local(this auto&& t, const glm::quat& rotation) {
+        t.rotation = t.rotation * rotation;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& rotate_local(this auto&& t, const glm::vec3& axis, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, axis));
+    }
+    auto&& rotate_local_x(this auto&& t, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, glm::vec3(1.0f, 0.0f, 0.0f)));
+    }
+    auto&& rotate_local_y(this auto&& t, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f)));
+    }
+    auto&& rotate_local_z(this auto&& t, float angle) {
+        return t.rotate_local(glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f)));
+    }
+    auto&& translate(this auto&& t, const glm::vec3& translation) {
+        t.translation += translation;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& translate(this auto&& t, float x, float y, float z) { return t.translate(glm::vec3(x, y, z)); }
+    auto&& scale(this auto&& t, const glm::vec3& scale) {
+        t.scaler *= scale;
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& scale(this auto&& t, float x, float y, float z) { return t.scale(glm::vec3(x, y, z)); }
+
+    auto&& translate_around(this auto&& t, const glm::vec3& point, const glm::quat& rotation) {
+        t.translation = point + rotation * (t.translation - point);
+        return std::forward<decltype(t)>(t);
+    }
+    auto&& rotate_around(this auto&& t, const glm::vec3& point, const glm::quat& rotation) {
+        return t.translate_around(point, rotation).rotate(rotation);
+    }
+
+    TransformT operator*(this TransformT t, const TransformT& other) {
+        t.translation = other * t.translation;
+        t.rotation    = other.rotation * t.rotation;
+        t.scaler *= other.scaler;
+        return t;
+    }
+    glm::vec3 operator*(this const TransformT& t, const glm::vec3& v) {
+        return t.translation + t.rotation * (v * t.scaler);
+    }
+
+    TransformT mul_transform(this const TransformT& t, const TransformT& other) { return t * other; }
+    glm::vec3 mul_vec3(this const TransformT& t, const glm::vec3& v) { return t * v; }
+};
+
+using Transform  = TransformT<float>;
+using DTransform = TransformT<double>;
+
+struct GlobalTransform {
+    glm::mat4 matrix{1.0f};
+};
+
+enum class TransformSets {
+    CalculateGlobalTransform = 0,
+};
+
+struct TransformPlugin {
+    void build(epix::App& app);
+};
+
+}  // namespace epix::transform
diff --git a/epix_engine/transform/CMakeLists.txt b/epix_engine/transform/CMakeLists.txt
index 61c2f79..f2967ca 100644
--- a/epix_engine/transform/CMakeLists.txt
+++ b/epix_engine/transform/CMakeLists.txt
@@ -3,6 +3,8 @@ list(APPEND MODULE_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR}/include)
 
 add_library(epix_transform STATIC ${MODULE_SOURCES})
 epix_parse_options(epix_transform)
+# Enable C++20 for module support
+target_compile_features(epix_transform PUBLIC cxx_std_20)
 target_include_directories(epix_transform PUBLIC ${MODULE_INCLUDES})
 target_link_libraries(epix_transform PUBLIC epix_core)
 target_link_libraries(epix_transform PUBLIC glm::glm)
\ No newline at end of file
diff --git a/epix_engine/transform/include/epix/transform.hpp b/epix_engine/transform/include/epix/transform.hpp
index 331bdbf..a2bb2ae 100644
--- a/epix_engine/transform/include/epix/transform.hpp
+++ b/epix_engine/transform/include/epix/transform.hpp
@@ -1,138 +1,11 @@
 #pragma once
 
-#include <epix/core.hpp>
-#include <glm/glm.hpp>
-#include <glm/gtc/matrix_transform.hpp>
-#include <glm/gtc/quaternion.hpp>
-#include <glm/gtc/type_ptr.hpp>
+// Compatibility header for epix.transform module
+// This file imports the C++20 module for backward compatibility
+// Original header archived to: epix_engine/archived_headers/transform/
 
-namespace epix::transform {
-template <typename T = float>
-struct TransformT {
-    glm::vec<3, T> translation{0.0f, 0.0f, 0.0f};
-    glm::qua<T> rotation{1.0f, 0.0f, 0.0f, 0.0f};
-    glm::vec<3, T> scaler{1.0f, 1.0f, 1.0f};
+// Import the C++20 module
+import epix.transform;
 
-    static TransformT identity() { return TransformT(); }
-    static TransformT from_matrix(const glm::mat4& matrix) {
-        TransformT t;
-        t.translation = glm::vec3(matrix[3]);
-        t.scaler      = glm::vec3(glm::length(matrix[0]), glm::length(matrix[1]), glm::length(matrix[2]));
-        // get the pure rotation matrix
-        glm::mat3 rotationMatrix = glm::mat3(matrix);
-        // normalize the rotation matrix
-        rotationMatrix[0] /= t.scaler.x;
-        rotationMatrix[1] /= t.scaler.y;
-        rotationMatrix[2] /= t.scaler.z;
-        t.rotation = glm::quat_cast(rotationMatrix);
-        return t;
-    }
-    static TransformT from_translation(const glm::vec3& translation) {
-        TransformT t;
-        t.translation = translation;
-        return t;
-    }
-    static TransformT from_xyz(float x, float y, float z) { return from_translation(glm::vec3(x, y, z)); }
-    static TransformT from_rotation(const glm::quat& rotation) {
-        TransformT t;
-        t.rotation = rotation;
-        return t;
-    }
-    static TransformT from_scale(const glm::vec3& scale) {
-        TransformT t;
-        t.scaler = scale;
-        return t;
-    }
-
-    auto&& look_at(this auto&& t, const glm::vec3& target, const glm::vec3& up) {
-        glm::vec3 direction = glm::normalize(target - t.translation);
-        t.rotation          = glm::quatLookAt(direction, up);
-        return std::forward<decltype(t)>(t);
-    }
-    auto&& look_to(this auto&& t, const glm::vec3& direction, const glm::vec3& up) {
-        t.rotation = glm::quatLookAt(direction, up);
-        return std::forward<decltype(t)>(t);
-    }
-
-    glm::mat4 to_matrix(this const TransformT& t) {
-        glm::mat3 rotate = glm::mat3_cast(t.rotation);
-        glm::mat4 matrix(glm::vec4(rotate[0] * t.scaler.x, 0.0f), glm::vec4(rotate[1] * t.scaler.y, 0.0f),
-                         glm::vec4(rotate[2] * t.scaler.z, 0.0f), glm::vec4(t.translation, 1.0f));
-        return matrix;
-    }
-
-    glm::vec3 local_x(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(1.0f, 0.0f, 0.0f)); }
-    glm::vec3 local_y(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(0.0f, 1.0f, 0.0f)); }
-    glm::vec3 local_z(this const TransformT& t) { return glm::normalize(t.rotation * glm::vec3(0.0f, 0.0f, 1.0f)); }
-
-    // Adding rotation in the parent space
-    auto&& rotate(this auto&& t, const glm::quat& rotation) {
-        t.rotation = rotation * t.rotation;
-        return std::forward<decltype(t)>(t);
-    }
-    auto&& rotate(this auto&& t, const glm::vec3& axis, float angle) { return t.rotate(glm::angleAxis(angle, axis)); }
-    auto&& rotate_x(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(1.0f, 0.0f, 0.0f))); }
-    auto&& rotate_y(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f))); }
-    auto&& rotate_z(this auto&& t, float angle) { return t.rotate(glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f))); }
-    // Adding rotation in the local space
-    auto&& rotate_local(this auto&& t, const glm::quat& rotation) {
-        t.rotation = t.rotation * rotation;
-        return std::forward<decltype(t)>(t);
-    }
-    auto&& rotate_local(this auto&& t, const glm::vec3& axis, float angle) {
-        return t.rotate_local(glm::angleAxis(angle, axis));
-    }
-    auto&& rotate_local_x(this auto&& t, float angle) {
-        return t.rotate_local(glm::angleAxis(angle, glm::vec3(1.0f, 0.0f, 0.0f)));
-    }
-    auto&& rotate_local_y(this auto&& t, float angle) {
-        return t.rotate_local(glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f)));
-    }
-    auto&& rotate_local_z(this auto&& t, float angle) {
-        return t.rotate_local(glm::angleAxis(angle, glm::vec3(0.0f, 0.0f, 1.0f)));
-    }
-    auto&& translate(this auto&& t, const glm::vec3& translation) {
-        t.translation += translation;
-        return std::forward<decltype(t)>(t);
-    }
-    auto&& translate(this auto&& t, float x, float y, float z) { return t.translate(glm::vec3(x, y, z)); }
-    auto&& scale(this auto&& t, const glm::vec3& scale) {
-        t.scaler *= scale;
-        return std::forward<decltype(t)>(t);
-    }
-    auto&& scale(this auto&& t, float x, float y, float z) { return t.scale(glm::vec3(x, y, z)); }
-
-    auto&& translate_around(this auto&& t, const glm::vec3& point, const glm::quat& rotation) {
-        t.translation = point + rotation * (t.translation - point);
-        return std::forward<decltype(t)>(t);
-    }
-    auto&& rotate_around(this auto&& t, const glm::vec3& point, const glm::quat& rotation) {
-        return t.translate_around(point, rotation).rotate(rotation);
-    }
-
-    TransformT operator*(this TransformT t, const TransformT& other) {
-        t.translation = other * t.translation;
-        t.rotation    = other.rotation * t.rotation;
-        t.scaler *= other.scaler;
-        return t;
-    }
-    glm::vec3 operator*(this const TransformT& t, const glm::vec3& v) {
-        return t.translation + t.rotation * (v * t.scaler);
-    }
-
-    TransformT mul_transform(this const TransformT& t, const TransformT& other) { return t * other; }
-    glm::vec3 mul_vec3(this const TransformT& t, const glm::vec3& v) { return t * v; }
-};
-using Transform  = TransformT<float>;
-using DTransform = TransformT<double>;
-struct GlobalTransform {
-    glm::mat4 matrix{1.0f};
-};
-
-enum class TransformSets {
-    CalculateGlobalTransform = 0,
-};
-struct TransformPlugin {
-    void build(App& app);
-};
-}  // namespace epix::transform
\ No newline at end of file
+// The module exports everything in namespace epix::transform
+// No additional declarations needed - the module interface provides all symbols
diff --git a/epix_engine/transform/src/plugin.cpp b/epix_engine/transform/src/plugin.cpp.old
similarity index 100%
rename from epix_engine/transform/src/plugin.cpp
rename to epix_engine/transform/src/plugin.cpp.old
diff --git a/epix_engine/transform/src/plugin_module.cpp b/epix_engine/transform/src/plugin_module.cpp
new file mode 100644
index 0000000..312dd68
--- /dev/null
+++ b/epix_engine/transform/src/plugin_module.cpp
@@ -0,0 +1,52 @@
+// Module implementation for epix.transform
+module;
+
+// Private module fragment - implementation-specific includes
+#include <deque>
+#include <tuple>
+#include <unordered_map>
+
+module epix.transform;
+
+using namespace epix;
+using namespace epix::transform;
+
+void insert_global_transform(Commands cmd,
+                             Query<Item<Entity>, Filter<With<Transform>, Without<GlobalTransform>>> query) {
+    for (auto&& [entity] : query.iter()) {
+        cmd.entity(entity).insert(GlobalTransform{.matrix = glm::mat4(1.0f)});
+    }
+}
+
+void calculate_global_transform(Query<Item<Entity, const Transform&, Opt<const Parent&>, Mut<GlobalTransform>>> query) {
+    std::deque<std::tuple<const Transform&, const Parent&, GlobalTransform&>> toProcess;
+    std::unordered_map<Entity, GlobalTransform*> globalTransforms;
+    for (auto&& [entity, transform, parent, globalTransform] : query.iter()) {
+        if (parent) {
+            toProcess.emplace_back(transform, *parent, globalTransform);
+        } else {
+            globalTransform->matrix  = transform.to_matrix();
+            globalTransforms[entity] = globalTransform.ptr_mut();
+        }
+    }
+    while (!toProcess.empty()) {
+        auto [transform, parent, globalTransform] = toProcess.front();
+        toProcess.pop_front();
+
+        auto it = globalTransforms.find(parent.entity);
+        if (it != globalTransforms.end()) {
+            globalTransform.matrix = it->second->matrix * transform.to_matrix();
+        } else {
+            toProcess.emplace_back(transform, parent, globalTransform);
+        }
+    }
+}
+
+void TransformPlugin::build(epix::App& app) {
+    app.add_systems(
+        Last,
+        into(into(calculate_global_transform)
+                 .in_set(TransformSets::CalculateGlobalTransform)
+                 .set_name("calculate global transform"),
+             into(insert_global_transform).before(calculate_global_transform).set_name("insert global transform")));
+}
